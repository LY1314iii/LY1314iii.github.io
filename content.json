{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-10-17T12:46:16.000Z","updated":"2021-10-17T12:46:32.042Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-17T12:40:50.000Z","updated":"2021-10-17T12:44:20.983Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-10-17T12:43:18.000Z","updated":"2021-10-17T12:43:55.043Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"404","date":"2021-10-17T12:55:08.000Z","updated":"2021-10-17T12:55:29.398Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-10-17T12:52:16.000Z","updated":"2021-10-17T12:52:44.249Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-10-17T12:52:59.000Z","updated":"2021-10-17T12:53:10.506Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"选择器优先级","date":"2021-10-09T07:16:23.799Z","updated":"2021-09-25T15:40:11.781Z","comments":true,"path":"2021/10/09/选择器优先级/","link":"","permalink":"http://example.com/2021/10/09/%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7/","excerpt":"","text":"选择器优先级 ！important 内行样式 id 类 属性 伪类 伪元素 标签 通配符 123456789101112//方法一div&#123; width:300px; height:100px; margin:50px auto;&#125;//方法二设置line-height等于自身高度div&#123; height：100px; line-height:100px; text-algin:center;&#125; flex布局","categories":[],"tags":[]},{"title":"","slug":"项目","date":"2021-10-09T07:16:23.796Z","updated":"2021-06-21T14:04:12.032Z","comments":true,"path":"2021/10/09/项目/","link":"","permalink":"http://example.com/2021/10/09/%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"开发依赖： less loader和less css：1box-sizing: border-box; git12345678git status //查看当前项目中源代码的状态git add . //将所有文件添加到暂存区git commit -m &quot;完成了登录功能&quot; //把暂存区代码提交到本地仓库中git branck //查看当前分支git checked master //切换到master分支git merage login //把login分支合并到master分支上git push //将当前分支推送到码云中git push -u origin login //将本地login分支推送到云端orgin的login保存","categories":[],"tags":[]},{"title":"","slug":"数据结构","date":"2021-10-09T07:16:23.793Z","updated":"2021-07-12T09:49:51.496Z","comments":true,"path":"2021/10/09/数据结构/","link":"","permalink":"http://example.com/2021/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"数据结构 算法（Algorithm） 栈（stack）后进先出 向栈插入元素叫：进栈、入栈、压栈 从栈删除元素叫：出栈、退栈 队列（Queue）先进先出 链表（Linked list）","categories":[],"tags":[]},{"title":"","slug":"试","date":"2021-10-09T07:16:23.790Z","updated":"2021-07-26T03:15:23.686Z","comments":true,"path":"2021/10/09/试/","link":"","permalink":"http://example.com/2021/10/09/%E8%AF%95/","excerpt":"","text":"JS中函数参数值传递和引用传递js堆与栈 运算符优先级js event loop以及宏任务和微任务； var a = [];a.push 最后添加a.shift 前面删除a.concata.splice （索引，长度，值） split 正则 数据类型 1null == undefined 变量提升 闭包 1234//只要 协议 、 域名 、 端口 有任何一个 不同, 都被当作是 不同 的域。js可以使用jsonp进行跨域通过修改document.domain来跨子域使用window.name来进行跨域 1、自我介绍2、水平垂直居中的方法√1234567margin：0 autotransform:(-50%,-50%)text-algin:centerline-height:他的heightdisplay:flexjustify-content:center 3、flex的属性√ 属性 描述 display 规定用于 HTML 元素的盒类型。 flex-direction 规定弹性容器内的弹性项目的方向。 justify-content 当弹性项目没有用到主轴上的所有可用空间时，水平对齐这些项目。 align-items 当弹性项目没有用到主轴上的所有可用空间时，垂直对齐这些项。 flex-wrap 规定弹性项目是否应该换行，若一条 flex 线上没有足够的空间容纳它们。 align-content 修改 flex-wrap 属性的行为。与 align-items 相似，但它不对齐弹性项目，而是对齐 flex 线。 flex-flow flex-direction 和 flex-wrap 的简写属性。 order 规定弹性项目相对于同一容器内其余弹性项目的顺序。 align-self 用于弹性项目。覆盖容器的 align-items 属性。 flex flex-grow、flex-shrink 以及 flex-basis 属性的简写属性。 4、position的粘滞定位sticky×5、BFC的触发条件√6、var、let、const的区别√7、修改this指向√8、为什么const定义的变量不能被修改？复合类型为什么可以被修改？×9、跨域以及实现其的方案√10、Jsonp的原理，怎么实现跨域的（同9）×11、window.name+iframe又是如何实现跨域的？说原理×12、前端安全√13、点击劫持里的iframe是如何内嵌到第三方网页上实现点击劫持的呢？√14、CSRF攻击，b站是如何获取到a站的cookie信息的？说原理×15、反转链表×16、一个有序数组（数据量很大），要求查找一个数√17、vue数据双向绑定的原理，如何达到视图更新的√18、watch和computed之间的关系√19、data不发生更新时，conputed还会进行缓存操作吗？还会执行吗？×20、说打印结果，为什么？√12345678910111213141516171819202122function arr()&#123; setTimeout(function()&#123; console.log(&#x27;1&#x27;); &#125;,0) async function async1()&#123; console.log(&#x27;4&#x27;); await async2(); console.log(&#x27;6&#x27;); &#125; async function async2()&#123; console.log(&#x27;5&#x27;); &#125; async1(); new Promise(function(resolve,reject)&#123; console.log(&#x27;2&#x27;); resolve(); &#125;).then(function(e2)&#123; console.log(&#x27;h&#x27;); &#125;) console.log(&#x27;3&#x27;); &#125; 21、vue中的v-for的key的作用√key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果 22、vue是如何获取到DOM节点变化的×方法1：直接给相应的元素加id,然后再document.getElementById(“id”);获取，然后设置相应属性或样式 方法2：使用ref,给相应的元素加ref=“name” 然后再this.$refs.name获取到该元素 23、服务器端是如何解析vue组件进行渲染的，与客户端渲染有何不同×24、媒体查询×\\1. 自我介绍 为什么选前端，看了哪些书。 ​ \\2. 解释了一下提前批的概念（我个人的理解），不能来实习的话会发一个秋招的直通车（免笔试和一面），能来实习的话发offer。 \\3. 介绍一下dom 跟 bom\\4. 介绍一下浏览器的渲染过程​ \\5. 介绍一下css选择器 ``` 简单选择器（根据名称、id、类来选取元素） 组合器选择器（根据它们之间的特定关系来选取元素） 伪类选择器（根据特定状态选取元素） 伪元素选择器（选取元素的一部分并设置其样式） 属性选择器（根据属性或属性值来选取元素）12345678910111213141516171819202122 \\6. 介绍一下伪类和伪元素的区别，它们有哪些值？ 伪类选择器| [::after](https://www.w3school.com.cn/cssref/selector_after.asp) | p::after | 在每个 &lt;p&gt; 元素之后插入内容。 || ------------------------------------------------------------ | --------------- | ----------------------------- || [::before](https://www.w3school.com.cn/cssref/selector_before.asp) | p::before | 在每个 &lt;p&gt; 元素之前插入内容。 || [::first-letter](https://www.w3school.com.cn/cssref/selector_first-letter.asp) | p::first-letter | 选择每个 &lt;p&gt; 元素的首字母。 || [::first-line](https://www.w3school.com.cn/cssref/selector_first-line.asp) | p::first-line | 选择每个 &lt;p&gt; 元素的首行。 || [::selection](https://www.w3school.com.cn/cssref/selector_selection.asp) | p::selection | 选择用户选择的元素部分。 |## \\7. vue3.0了解过吗？介绍一下跟2.0的区别 \\8. 水平垂直居中手写### 文本水平居中（图片、按钮、文字等行内元素）```csstext-align : center; div块级元素水平居中1margin : auto; 一行文字垂直居中（行内元素）1line-height : 他的height; transform1transform：translate（-50%，-50%） 利用flex布局12display: flex;justify-content: center; NaN==NaN //返回false，NaN和所有值包括自己都不相等 变量提升123console.log(foo); // undefinedvar foo = &#x27;小花猫&#x27;;console.log(foo) // 小花猫 相当于： 1234var foo;console.log(foo);foo = &#x27;小花猫&#x27;;console.log(foo); 只有函数声明形式才有函数提升 函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被变量赋值后覆盖 123// 声明式function foo ()&#123;&#125; 函数提升，相当于： 123// 函数字面量var foo = function () &#123;&#125; 12345678910https的SSL加密是在传输层实现的。(1)http和https的基本概念http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。(2)http和https的区别？http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。 dom元素 以下代码是用于创建 元素: 1var para = document.createElement(&quot;p&quot;); 为 元素创建一个新的文本节点： 1var node = document.createTextNode(&quot;这是一个新的段落。&quot;); 将文本节点添加到 元素中： 1para.appendChild(node); 最后，在一个已存在的元素中添加 p 元素。 查找已存在的元素： 1var element = document.getElementById(&quot;div1&quot;); 添加到已存在的元素中: 1element.appendChild(para); 消除超链接下划线1text-decoration: none 消除li前的小圆点123list-style-type:none或list-style:none arr.some(fn)/arr.every(fn) 检查数组。 与map类似，对数组的每个元素调用函数fn。如果任何/所有结果为true，则返回true，否则返回false。 这两个方法的行为类似于||和&amp;&amp;运算符：如果fn返回一个真值，arr.some()立即返回true并停止迭代其余数组项；如果fn返回一个假值，arr.every()立即返回false并停止对其余数组项的迭代。 一面（1小时）面试前10分钟找了个地方，打开面试链接等待面试。（约好时间后会发一封面试的邮件，里面是牛客网的面试链接，这个在牛客网上有，可以先体验体验）之后就是面试官准时进来，打了打招呼后，开始面试。 为什么选择前端？ 12345678910111213141516讲讲浏览器从输入网址到打开网页的整个过程，越细致越好。## 输入URL到页面加载显示完成发生了什么?### 参考回答：DNS解析TCP连接发送HTTP请求服务器处理请求并返回HTTP报文浏览器解析渲染页面连接结束 JS 事件循环机制？JS es6新内容？你提到了map，讲讲和object有什么区别？箭头函数和普通函数的区别？跨域，相关的几个请求头的含义。 一个盒子从中间开始，碰到最左边的边界往右移动，碰到最右边的边界往左移动，如此循环，问怎么做？你提到了requestAnimationFrame，讲讲和setInterval的区别？用过canvas吗，如果要实现一个一笔一画写汉字的效果，应该怎么做？算法题：写一个最多能并发执行n个promise的队列算法题：给树上每个节点的父亲节点，还原树反问二面（1小时）等了大概3分钟，二面面试官就进来了。笑眯眯的表示00后都开始找工作了，想自己当初搞前端的年代……打招呼。表示将从HTML，CSS，JS开始聊聊。 HTML中h标签有多少个，表示段落的标签是哪个？表示列表的标签有多少个（其实是有三个！！）表示引用的标签是什么？对语义化的看法？再到CSS部分，大小单位里面有一个单位是相对字体大小的，是什么？控制字体换行，大小写转换的属性？怎么设置一个圆形？如果设置的值超过50%会发生什么？还有好多忘记了……再到JS部分，说说喜欢JS的什么地方（说了函数式forEach，map哪个更贴近函数式思想？还有很多关于JS的基础问题不过也忘了……HTTP2.0了解吗，讲讲和HTTP1.1的区别git的基本操作，切换分支，合并，rebase等等的xss攻击讲一下，如何预防？有没有搞搞自己喜欢的技术啊，比如上传个npm包等等。（只玩过electron算法题：一个简单的正则匹配字符串之后替换（正好忘记了正则replace的函数是怎么用的了呜呜呜，愣是写了半天for循环做。。。简单题：async-await改写一个回调地狱三面 问简历上的项目和框架。 介绍一下项目项目中的亮点？听你讲用到了localStorage，讲讲有什么需要注意的点？给了一个网页，问如果你来实现这个页面中间的部分，做一个组件要怎么做（考布局+基本框架用法），因为我用的Vue写项目，就用Vue去写了，在牛客上不能实时预览css效果还是挺尴尬的，不知道写的对不对，有点慌代码题：给一个网页，用原生JS获取页面里面某一个dom下的内容。算法题：树的根到叶子节点的最长路径。","categories":[],"tags":[]},{"title":"","slug":"前端面试题","date":"2021-10-09T07:16:23.787Z","updated":"2021-06-06T15:38:43.698Z","comments":true,"path":"2021/10/09/前端面试题/","link":"","permalink":"http://example.com/2021/10/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"JavaScript 数据类型**值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。 引用数据类型：对象(Object)、数组(Array)、函数(Function)。 2.Ajax如何使用 一个完整的AJAX请求包括五个步骤： （1）创建XMLHTTPRequest对象 （2）使用open方法创建http请求，并设置请求地址 xhr.open（get/post，url，async，true（异步），false（同步））经常使用前三个参数 （3）设置发送的数据，用send发送请求 （4）注册事件（给ajax设置事件） （5）获取响应并更新页面 3.如何判断一个数据是NaN NaN 非数字 但是用type of检测是number类型 利用NaN的定义 用type of判断是否为number类型并且判断是否满足isnan利用NaN是唯一一个不等于任何自身的特点 n！==n利用ES6中提供的Object.is()方法（判断两个值是否相等） n==nan 4.Js中null与undefined区别 （1）相同点： 用if判断时，两者都会被转换成false （2）不同点： number转换的值不同 number（null）为0 number（undefined）为NaN Null表示一个值被定义了，但是这个值是空值 Undefined 变量声明但未赋值 5.闭包是什么？有什么特性？对页面会有什么影响 闭包可以简单理解成：定义在一个函数内部的函数。其中一个内部函数在包含它们的外部函数之外被调用时，就会形成闭包。 特点： 1.函数嵌套函数。 2.函数内部可以引用外部的参数和变量。 3.参数和变量不会被垃圾回收机制回收。 使用： 1.读取函数内部的变量； 2.这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除。 优点： 1:变量长期驻扎在内存中； 2:避免全局变量的污染； 3:私有成员的存在 ； 缺点：会造成内存泄露 6.Js中常见的内存泄漏： （1）意外的全局变量 （2）被遗忘的计时器或回调函数 （3）脱离DOM的引用 （4）闭包 7.7.事件委托是什么？如何确定事件源（Event.target 谁调用谁就是事件源） JS高程上讲：事件委托就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。 事件委托，称事件代理，是js中很常用的绑定事件的技巧，事件委托就是把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务，事件委托的原理是DOM元素的事件冒泡 8.什么是事件冒泡？ 一个事件触发后，会在子元素和父元素之间传播，这种传播分为三个阶段， 捕获阶段（从window对象传导到目标节点（从外到里），这个阶段不会响应任何事件），目标阶段，（在目标节点上触发），冒泡阶段（从目标节点传导回window对象（从里到外）），事件委托/事件代理就是利用事件冒泡的机制把里层需要响应的事件绑定到外层 10.ES6新特性 const和let、模板字符串、箭头函数、函数的参数默认值、对象和数组解构、for…of 和 for…in、ES6中的类 11.Let与var与const的区别 Var声明的变量会挂载在window上，而let和const声明的变量不会 Var声明的变量存在变量提升，let和const不存在变量提升 同一作用域下var可以声明同名变量，let和const不可以 Let和const声明会形成块级作用域 Let暂存死区 Const一旦声明必须赋值，不能用null占位，声明后不能再修改，如果声明的是复合类型数据，可以修改属性 12.数组方法有哪些请简述 push() 从后面添加元素，返回值为添加完后的数组的长度 arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素 arr.shift() 从前面删除元素，只能删除一个 返回值是删除的元素 arr.unshift() 从前面添加元素, 返回值是添加完后的数组的长度 arr.splice(i,n) 删除从i(索引值)开始之后的那个元素。返回值是删除的元素 arr.concat() 连接两个数组 返回值为连接后的新数组 str.split() 将字符串转化为数组 arr.sort() 将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的 arr.reverse() 将数组反转,返回值是反转后的数组 arr.slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组 arr.forEach(callback) 遍历数组,无return 即使有return，也不会返回任何值，并且会影响原来的数组 arr.map(callback) 映射数组(遍历数组),有return 返回一个新数组 。 arr.filter(callback) 过滤数组，返回一个满足要求的数组","categories":[],"tags":[]},{"title":"","slug":"面试","date":"2021-10-09T07:16:23.783Z","updated":"2021-07-20T13:22:31.945Z","comments":true,"path":"2021/10/09/面试/","link":"","permalink":"http://example.com/2021/10/09/%E9%9D%A2%E8%AF%95/","excerpt":"","text":"1.自我介绍 2.为什么选择前端 3.webpack配置的流程 4.ajax同步还是异步？如果变成同步应该怎么办？ 5.css选择器的类型和权重 6.http的理解 7.cookie sessionstorage localstorage 8.实现v-model 9.为什么vue的data是一个函数 10.git步骤和优点 11.httpcode \\1. 项目中的亮点? \\2. axios拦截器的原理? \\3. axios怎么区分客户端和服务器端的请求? \\4. {}、new Object()，Object.create({})的区别? \\5. new做了什么？ \\6. CSS渲染的详细过程？ \\7. 哪些css属性会导致重排？ \\8. translate 3d 和 flex 在渲染上有什么不同的地方？ \\9. flex:1 是什么意思？ \\10. 304什么意思？也就是要讲讲http 缓存机制 \\11. cookie有哪些属性？samesite了解嘛？ \\12. cookie跨域吗？那cookie跨域要怎么做？ \\13. 讲讲同源策略cors？ \\14. nginx怎么配置cors？ \\15. 讲讲css中的position？ \\16. 浏览器的进程和线程间怎么做的？区别？ \\17. js中一个任务崩了，怎么做才能不影响其他的任务？ \\18. 浏览器的不同tab间是线程还是进程？ \\19. 事件循环机制 \\20. http2.0有什么缺点？为什么会有http3.0? \\21. vue 2.0和3.0中关于数据绑定的区别 \\22. 讲讲Object.definProperty() 和 ES6中的Proxy？或者说 Proxy有哪些好处？ \\23. 知道JWT吗？JWT（Json Web Token） \\24. 一道关于事件循环，宏任务和微任务的输出题，具体记不清了 25 一个场景题：假设有10个接口，封装一个工具，实现10个接口并发请求，但保证最后的结果俺顺序输出。大概是这个意思 \\26. 算法题：有序数组合并 具体问题如下： \\1. 数据类型 \\2. DOM和BOM \\3. 事件绑定、解绑 \\4. 垃圾回收机制 \\5. Websoket了解吗？（了解，我项目里用了） \\6. 跨域了解吗？（了解，我自己封装过Jsonp） \\7. CSS预处理用过吗（我说只用过less） \\8. 用过什么框架（Vue） \\9. Vue3了解吗？（我说没用过，但是我看过一点，然后说了我知道的，我还提了一下2和3响应式原理的区别） \\10. 用过什么UI框架（Element-UI） 作者：无敌的小荔枝链接：https://www.nowcoder.com/discuss/686712?source_id=discuss_experience_nctrack&amp;channel=-1来源：牛客网 具体问题如下： \\1. 数据类型 \\2. DOM和BOM \\3. 事件绑定、解绑 \\4. 垃圾回收机制 \\5. Websoket了解吗？（了解，我项目里用了） \\6. 跨域了解吗？（了解，我自己封装过Jsonp） \\7. CSS预处理用过吗（我说只用过less） \\8. 用过什么框架（Vue） \\9. Vue3了解吗？（我说没用过，但是我看过一点，然后说了我知道的，我还提了一下2和3响应式原理的区别） \\10. 用过什么UI框架（Element-UI）","categories":[],"tags":[]},{"title":"","slug":"博客","date":"2021-10-09T07:16:23.780Z","updated":"2021-05-29T06:26:05.764Z","comments":true,"path":"2021/10/09/博客/","link":"","permalink":"http://example.com/2021/10/09/%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"node -v #查看node版本npm -v #查看npm版本 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 此时你还需要配置： 12$ git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称$ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本cnpm install -g hexo-cli #安装hexo框架hexo -v #查看hexo版本mkdir blog #创建blog目录cd blog #进入blog目录hexo init #生成博客 初始化博客hexo s #启动本地博客服务http://localhost:4000/ #本地访问地址hexo n 我的第一篇文章 #创建新的文章#返回blog目录hexo clean #清理hexo g #生成#Github创建一个新的仓库 YourGithubName.github.iocnpm install –save hexo-deployer-git #在blog目录下安装git部署插件-—#配置_config.yml-—- # Deployment ## Docs: https://hexo.io/docs/deployment.html ​ deploy: type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git branch: master-—-hexo d #部署到Github仓库里https://YourGithubName.github.io/ #访问这个地址可以查看博客 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载yilia主题到本地 #修改hexo根目录下的 _config.yml 文件 ： theme: yilia hexo c #清理一下hexo g #生成hexo d #部署到远程Github仓库https://YourGithubName.github.io/ #查看博客","categories":[],"tags":[]},{"title":"","slug":"Vuex笔记","date":"2021-10-09T07:16:23.777Z","updated":"2021-06-22T13:37:42.866Z","comments":true,"path":"2021/10/09/Vuex笔记/","link":"","permalink":"http://example.com/2021/10/09/Vuex%E7%AC%94%E8%AE%B0/","excerpt":"","text":"VuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 调试工具：vue devtools Vuex就像眼镜：您自会知道什么时候需要它。 1、state在store中定义数据，在组件中直接使用： 目录：store/index.js 12345678910export default new Vuex.Store(&#123; // state相当于组件中的data，专门用来存放全局的数据 state: &#123; num: 0 &#125;, getters: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;&#125;) 目录：Home.vue 1234567891011&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h2&gt;Home页面的数字：&#123;&#123;$store.state.num&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; &#125;&lt;/script&gt; 或者写为： 123456789101112131415&lt;template&gt; &lt;div class=&quot;about&quot;&gt; &lt;h2&gt;About页面的数字：&#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; computed: &#123; num()&#123; return this.$store.state.num &#125; &#125;&#125;&lt;/script&gt; 2、getters将组件中统一使用的computed都放到getters里面来操作 目录：store/index.js 123456789101112131415export default new Vuex.Store(&#123; // state相当于组件中的data，专门用来存放全局的数据 state: &#123; num: 0 &#125;, // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的 getters: &#123; getNum(state) &#123; return state.num &#125; &#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;&#125;) 目录：Home.vue 1234567891011&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h2&gt;Home页面的数字：&#123;&#123;$store.getters.getNum&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; &#125;&lt;/script&gt; 3、mutations更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 目录：store/index.js 12345678910111213141516171819202122export default new Vuex.Store(&#123; // state相当于组件中的data，专门用来存放全局的数据 state: &#123; num: 0 &#125;, // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的 getters: &#123; getNum(state) &#123; return state.num &#125; &#125;, // mutations相当于组件中的methods，但是它不能使用异步方法（定时器、axios） mutations: &#123; // 让num累加 // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined increase(state, payload)&#123; state.num += payload ? payload : 1; &#125; &#125;, actions: &#123;&#125;, modules: &#123;&#125;&#125;) 目录：Btn.vue 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;$store.commit(&#x27;increase&#x27;, 2)&quot;&gt;点击加1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; /* addFn()&#123; // 调用store中的mutations里的increase方法 // 传参的话，使用payload this.$store.commit(&#x27;increase&#x27;, 2) &#125; */ &#125;&#125;&lt;/script&gt; 4、actionsactions是store中专门用来处理异步的，实际修改状态值的，还是mutations 目录：store/index.js 123456789101112131415161718192021222324252627282930313233343536373839// 在store(仓库)下的index.js这份文件，就是用来做状态管理import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; // state相当于组件中的data，专门用来存放全局的数据 state: &#123; num: 0 &#125;, // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的 getters: &#123; getNum(state) &#123; return state.num &#125; &#125;, // mutations相当于组件中的methods，但是它不能使用异步方法（定时器、axios） mutations: &#123; // 让num累加 // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined increase(state, payload)&#123; state.num += payload ? payload : 1; &#125;, // 让num累减 decrease(state)&#123; state.num--; &#125; &#125;, // actions专门用来处理异步，实际修改状态值的，依然是mutations actions: &#123; // 点击了“减1”按钮后，放慢一秒再执行减法 decreaseAsync(context)&#123; context.commit(&#x27;decrease&#x27;) &#125; &#125;, modules: &#123;&#125;&#125;) 目录：Btn.vue 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;$store.commit(&#x27;increase&#x27;, 2)&quot;&gt;点击加1&lt;/button&gt; &lt;button @click=&quot;$store.dispatch(&#x27;decreaseAsync&#x27;)&quot;&gt;点击延迟减1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; /* addFn()&#123; // 调用store中的mutations里的increase方法 // 传参的话，使用payload this.$store.commit(&#x27;increase&#x27;, 2) &#125; reduceFn()&#123; this.$store.dispatch(&#x27;decreaseAsync&#x27;) &#125; */ &#125;&#125;&lt;/script&gt; 5、辅助函数mapState和mapGetters在组件中都是写在computed里面 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h2&gt;Home页面的数字：&#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;h2&gt;About页面的数字：&#123;&#123;getNum&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState, mapGetters &#125; from &#x27;vuex&#x27;export default &#123; computed: &#123; ...mapState([&#x27;num&#x27;]) ...mapGetters([&#x27;getNum&#x27;]) &#125;&#125;&lt;/script&gt; mapMutations和mapActions在组件中都是写在methods里面 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;increase(2)&quot;&gt;点击加1&lt;/button&gt; &lt;button @click=&quot;decreaseAsync()&quot;&gt;点击延迟减1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapMutations, mapActions &#125; from &#x27;vuex&#x27;export default &#123; methods: &#123; ...mapMutations([&#x27;increase&#x27;]), ...mapActions([&#x27;decreaseAsync&#x27;]) &#125;&#125;&lt;/script&gt; 6、拆分写法store中的所有属性，都可以拆分成单独的js文件来书写 7、modules我们的store可以认为是一个主模块，它下边可以分解为很多子模块，子模块都可以单独领出来写，写完再导入到主模块中。下面以 users 子模块举例： 将mutations中所有的方法，归纳起来。 目录：mutations_type.js 12345678910111213141516export const MUTATIONS_TYPE = &#123; INCREASE: &#x27;increase&#x27;, DECREASE: &#x27;decrease&#x27;&#125;export default &#123; // 让num累加 // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined [MUTATIONS_TYPE.INCREASE](state, payload)&#123; state.num += payload ? payload : 1; &#125;, // 让num累减 [MUTATIONS_TYPE.DECREASE](state)&#123; state.num--; &#125;&#125; 目录：store/index.js 1234567import mutations from &#x27;./mutaions_type&#x27;export default new Vuex.Store(&#123; ... mutations, ...&#125;) 组件中： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;about&quot;&gt; &lt;h2&gt;About页面的数字：&#123;&#123;getNum&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;increase()&quot;&gt;About的按钮，点击加1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters, mapMutations &#125; from &#x27;vuex&#x27;import &#123; MUTATIONS_TYPE &#125; from &#x27;@/store/mutaions_type.js&#x27;export default &#123; computed: &#123; ...mapGetters([&#x27;getNum&#x27;]) &#125;, methods: &#123; // 方法一： ...mapMutations([MUTATIONS_TYPE.INCREASE]) // 方法二： /* increase()&#123; this.$store.commit(MUTATIONS_TYPE.INCREASE) &#125; */ &#125;&#125;&lt;/script&gt;","categories":[],"tags":[]},{"title":"","slug":"this指向","date":"2021-10-09T07:16:23.774Z","updated":"2021-10-05T01:37:36.113Z","comments":true,"path":"2021/10/09/this指向/","link":"","permalink":"http://example.com/2021/10/09/this%E6%8C%87%E5%90%91/","excerpt":"","text":"this指向立即执行函数指向window","categories":[],"tags":[]},{"title":"","slug":"js(1)(1)(2)","date":"2021-10-09T07:16:23.770Z","updated":"2021-06-13T07:14:14.833Z","comments":true,"path":"2021/10/09/js(1)(1)(2)/","link":"","permalink":"http://example.com/2021/10/09/js(1)(1)(2)/","excerpt":"","text":"前端开发知识点：12345678910HTML&amp;CSS： 对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、 HTML5、CSS3、FlexboxJavaScript： 数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、 DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs其他： 移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力 123456789101112131415161718191、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。 2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。 3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。 4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。 5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。 6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型 7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们 8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。 9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。 10、JSON —— 作用、用途、设计结构。 **DOM**操作——怎样添加、移除、移动、复制、创建和查找节点。**1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //并没有insertAfter() 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强， 会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 11.Let与var与const的区别Var声明的变量会挂载在window上，而let和const声明的变量不会 Var声明的变量存在变量提升，let和const不存在变量提升 同一作用域下var可以声明同名变量，let和const、不可以 Let和const声明会形成块级作用域 Let暂存死区 Const一旦声明必须赋值，不能用null占位，声明后不能再修改，如果声明的是复合类型数据，可以修改属性 12.数组方法有哪些请简述push() 从后面添加元素，返回值为添加完后的数组的长度 arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素 arr.shift() 从前面删除元素，只能删除一个 返回值是删除的元素 arr.unshift() 从前面添加元素, 返回值是添加完后的数组的长度 arr.splice(i,n) 删除从i(索引值)开始之后的那个元素，n删除个数。返回值是删除的元素 arr.splice(i,n，’aa’，‘bb’)替换从i(索引值)，n个元素，替换为’aa’，‘bb’的元素 arr.splice(i,0，’aa’)插入从i(索引值)为’aa’的元素 arr.concat() 连接两个数组 返回值为连接后的新数组 str.split() 将字符串转化为数组 arr.sort() 将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的 arr.reverse() 将数组反转,返回值是反转后的数组 arr.slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组 arr.forEach(callback) 遍历数组,无return 即使有return，也不会返回任何值，并且会影响原来的数组 arr.map(callback) 映射数组(遍历数组),有return 返回一个新数组 。 arr.filter(callback) 过滤数组，返回一个满足要求的数组 如何实现浏览器多标签页之间的通信？1调用localStorage、cookie本地存储方式。 JavaScript的typeof返回类型有哪些？1Object（null和Array）、number、undefined、string、Boolean、function 类型转换1强制转换：parseInt();parseFloat();number(); ajax请求时get和post的区别？get：从服务器上获取数据，传送数据量小，安全性低，请求会被缓存，缓存是针对URL进行缓存的，get请求参数直接加在URL地址后面，一种参数组合就会产生一种URL的缓存，重复的请求结果是相同的； post：向服务器发送数据；传送数据量大，请求不会被缓存，参数封装在二进制的数据体中，服务器也不会记录参数，相对安全，所以涉及用户隐私的数据都要用post传送； http常用状态码？100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 你有哪些性能优化的方法？ 1. 尽可能的减少 HTTP 的请求数 content 2. 使用 CDN（Content Delivery Network） server 3. 添加 Expires 头(或者 Cache-control ) server 4. Gzip 组件 server 5. 将 CSS 样式放在页面的上方 css 6. 将脚本移动到底部（包括内联的） javascript 7. 避免使用 CSS 中的 Expressions css 8. 将 JavaScript 和 CSS 独立成外部文件 javascript css 9. 减少 DNS 查询 content 10. 压缩 JavaScript 和 CSS (包括内联的) javascript css 11. 避免重定向 server 12. 移除重复的脚本 javascript 13. 配置实体标签（ETags） css 14. 使 AJAX 缓存 深拷贝和浅拷贝基本类型指的是简单的数据段，引用类型指的是多个值构成的对象； var name = &quot;John&quot;; // 基本类型值 var obj = new Object(); obj.name = &quot;John&quot;; // obj 为引用类型值 在复制变量中，对于基本类型来说，两者互不影响， var num = 1; var num1 = num; // num1 = 1; var num1 = 3; // num还是1,不会变 浅拷贝和深拷贝的区别： 对于浅拷贝来说，对于一个数组（数组是一个对象），只要我们修改了一个拷贝数组，原数组也会跟着改变。 因为他们引用的是同一个地址的数据，拷贝的时候并没有给b数组创造独立的内存，只是把a数组指向数据的指针拷贝给了b； 而深拷贝就与其相反，将会给b数组创造独立的内存，并且将a数组的内容一一拷贝进来，两者互不影响。 实现深拷贝： 一：层级拷贝，用递归实现； 二：JSON解析 var b = JSON.parse(JSON.stringify(a)); 怎么让Chrome支持小于12px 的文字？我们的做法是： 针对谷歌浏览器内核，加webkit前缀，用transform:scale()这个属性进行缩放！ 1&lt;style&gt;pspan&#123;font-size:10px;-webkit-transform:scale(0.8);display:block;&#125;&lt;/style&gt;&lt;p&gt;&lt;span&gt;haorooms博客测试10px&lt;/span&gt;&lt;/p&gt; 3、渲染优化1.禁止使用iframe（阻塞父文档onload事件） iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。 2.禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）； 3、使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）； 4、对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU； 小图标优势在于： 1.减少HTTP请求； 2.避免文件跨域； 3.修改及时生效； 5、页面头部的 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的）； 6、页面头部 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的）； 7、页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程)； 8、网页Gzip，CDN托管，data缓存 ，图片服务器； 9、前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 10、用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 11、当需要设置的样式很多时设置className而不是直接操作style。 12、少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 13、避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 14、图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 15、 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。 向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法”优化”的。 事件的各个阶段121：捕获阶段 ---&gt; 2：目标阶段 ---&gt; 3：冒泡阶段document ---&gt; target目标 ----&gt; document 由此，addEventListener 的第三个参数设置为 true 和 false 的区别已经非常清晰了： true 表示该元素在事件的”捕获阶段”（由外往内传递时）响应事件； false 表示该元素在事件的”冒泡阶段”（由内向外传递时）响应事件。 let var const let: 允许你声明一个作用域被限制在块级中的变量、语句或者表达式 let 绑定不受变量提升的约束，这意味着let声明不会被提升到当前，该变量处于从块开始到初始化处理的”暂存死区”。 var: 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的, 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。 const 声明创建一个值的只读引用 (即指针)，这里就要介绍下 JS 常用类型: String、Number、Boolean、Array、Object、Null、Undefined。其中基本类型有 Undefined、Null、Boolean、Number、String，保存在栈中；复合类型 有 Array、Object ，保存在堆中； 基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 const申明基本数据类型时，再将其值改变时，将会造成报错， 例如 const a = 3 ; a = 5 时 将会报错；但是如果是复合类型时，如果只改变复合类型的其中某个Value项时， 将还是正常使用； 箭头函数语法比函数表达式更短，并且不绑定自己的 this，arguments，super 或 new.target。这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数。 快速的让一个数组乱序12345var arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(function()&#123; return Math.random() - 0.5;&#125;)console.log(arr); 首先，当 return 的值： 小于 0 ，那么 a 会被排列到 b 之前； 等于 0 ， a 和 b 的相对位置不变； 大于 0 ， b 会被排列到 a 之前； 这里你会发现起始的时候数组是正序排列，每当进行一次排列的时候， 都会先随机一个随机数（注意这里的每一次排列 指 每一个红框指一次排列， 共9次排列 ， 一次排列中可能存在多次比较）； 当一次排列的随机数大于 0.5 时 将会进行第二次比较， 当第二次随机数 仍然大于 0.5 时 ，将会再进行一次比较， 直到 随机数大于 0.5 或者排列到第一位； 当一次排列的随机数 小于 0.5 时 当前比较的两项索引将不会改变 ，继续下一次的排列； 可能用到的meta标签12345678&lt;!-- 设置缩放 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt; 其他meta标签123456789101112131415161718192021222324&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; 让图文不可复制这点应该大家 都很熟悉了， 某些时候【你懂的】为了快捷搜索答案，可是打死也不让你复制: 12345-webkit-user-select: none; -ms-user-select: none;-moz-user-select: none;-khtml-user-select: none;user-select: none; 盒子垂直水平居中这个问题好像面试必问的吔！反正我是必问的，哈哈！！！ 其实无关多少种实现思路，只要你能实现就可以！ 提供4种方法: 1、定位 盒子宽高已知， position: absolute; left: 50%; top: 50%; margin-left:-自身一半宽度; margin-top: -自身一半高度; 2、table-cell布局 父级 display: table-cell; vertical-align: middle; 子级 margin: 0 auto; 3、定位 + transform ; 适用于 子盒子 宽高不定时； （这里是本人常用方法） 123456position: relative / absolute;/*top和left偏移各为50%*/ top: 50%; left: 50%;/*translate(-50%,-50%) 偏移自身的宽和高的-50%*/transform: translate(-50%, -50%); 注意这里启动了3D硬件加速哦 会增加耗电量的 （至于何是3D加速 请看浏览器进程与线程篇） 4、flex 布局 1234567父级： /*flex 布局*/display: flex;/*实现垂直居中*/align-items: center;/*实现水平居中*/justify-content: center; 再加一种水平方向上居中 ：margin-left : 50% ; transform: translateX(-50%); 那有些网页为了尊重原创，复制的文本 都会被加上一段来源说明，是如何做到的呢？问的好！ 等的就是你这个问题 -_- 。 大致思路： 1、答案区域监听copy事件，并阻止这个事件的默认行为。 2、获取选中的内容（window.getSelection()）加上版权信息，然后设置到剪切板（clipboarddata.setData()）。 iframe的优缺点？1、缺点：在网页中使用框架结构最大的弊病是搜索引擎的”蜘蛛”程序无法解读这种页面。当”蜘蛛”程序遇到由数个框架组成的网页时，它们只看到框架而无法找到链 接，因此它们会以为该网站是个死站点，并且很快转身离去。对一个网站来说这无异于一场灾难。如果你想销售产品，你需要客户;如想得到客户，你首先要让人们 访问你的网站，而要做到这一点，你就非求助于搜索引擎不可。你花费了大量的时间、精力和金钱开设了一家网上商店，却又故意不让搜索引擎检索你，这就好象开 家零售商店，却将窗户全部漆成黑色，而且还不挂任何招牌一样。 2、优点：从上文中我们可以发现，使用ifame框架的弊端是无法被搜索引擎所爬行抓取。但凡事总是具有两面性。它的这个缺点也可能是他的优点。利用这一点那我 们就可以把我们站点上一些需要给我们的用户查看，但是不需要搜索引擎爬行的内容用ifame框架进行显示，这样就可以让ifram发挥真正的效果了，而且 有我们站点中的代码也可以得到很大的精简，举一个例子，就如笔者上文提到的添加微博直播信息，这些微博信息我们并不需要提供给搜索引擎，而我们需要提供的 是与访客的一个互动的体验，如下图所示，而如果我们使用ifame框架嵌入微博的信息，不仅可以简便的添加站点的微博直播平台，同时我们看到代码也十分的 精简。 iframe好在能够把原先的网页全部原封不动显示下来,但是如果用在首页,是搜索引擎最套讨厌的.那么你的网站即使做的在好,也排不到好的名次!如 果是动态网页，用include还好点！但是必须要去除他 的标签！ 框架的优点 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度) 方便制作导航栏 框架的缺点 会产生很多页面，不容易管理 不容易打印 浏览器的后退按钮无效 代码复杂,无法被一些搜索引擎索引到 多数小型的移动设备（PDA 手机）无法完全显示框架 多框架的页面会增加服务器的http请求 由于上面诸多缺点，因此不符合标准网页设计的理念,已经被标准网页设计抛弃 提示: 目前框架的所有优点完全可以使用Ajax实现，因此已经没有必要使用框架了。 CSS盒模型原理 1、W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。 CSS display:none和visibility:hidden的区别 visibility:hidden隐藏，但在浏览时保留位置 display:none视为不存在，且不加载 CDN（内容分发网络）是什么？在开发Web页面，考虑最多的问题之一是页面在客户端电脑的响应：时间越短，用户体验越好。 而制约用户体验的关键因素之一是浏览器下载Web文件大小，包括*.html、图片、*.js、*.css等文件。 为了最大化复用和节约带宽，故CDN应运而生：其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 webpack具有requireJs和browserify的功能，但仍有很多自己的新特性：\\1. 对 CommonJS 、 AMD、ES6的语法做了兼容 \\2. 对js、css、图片等资源文件都支持打包 \\3. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持 \\4. 有独立的配置文件webpack.config.js \\5. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间 \\6. 支持 SourceUrls 和SourceMaps，易于调试 \\7. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活 8.webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快 TCP和UDP的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。 ***创建ajax*过程(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. *你觉得前端工程的价值体现在哪*为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） *栈和队列的区别?*栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 *栈和堆的区别？*栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构。 *说说你对闭包的理解*使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 1.函数嵌套函数 2.函数内部可以引用外部的参数和变量 3.参数和变量不会被垃圾回收机制回收 ***创建ajax*的过程 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. var xmlHttp = new XMLHttpRequest(); xmlHttp.open(‘GET’,’demo.php’,’true’); xmlHttp.send() xmlHttp.onreadystatechange = function(){ ​ if(xmlHttp.readyState === 4 &amp; xmlHttp.status=== 200){ ​ } } **javascript**对象的几种创建方式**1，工厂模式 2，构造函数模式 3，原型模式 4，混合构造函数和原型模式 5，动态原型模式 6，寄生构造函数模式 7，稳妥构造函数模式 ***javascript**继承的6*种方法1，原型链继承 2，借用构造函数继承 3，组合继承(原型+借用构造) 4，原型式继承 5，寄生式继承 6，寄生组合式继承 *请解释什么是事件代理*事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。 ***attribute**和property*的区别是什么？attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 所以： 对于html的标准属性来说，attribute和property是同步的，是会自动更新的， 但是对于自定义的属性来说，他们是不同步的， *说说网络分层里七层模型是哪七层*§ 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS） § 传输层（TCP和UDP） § 网络层（IP） § 物理和数据链路层（以太网） 每一层的作用如下： 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 各种协议ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 *什么样的前端代码是好的*高复用低耦合，这样文件小，好维护，而且好扩展。 前端常见的设计模式主要有以下几种1. 单例模式2. 工厂模式3. 策略模式4. 代理模式5. 观察者模式6. 模块模式7. 构造函数模式8. 混合模式 HTTP请求报文HTTP请求报文由3部分组成（请求行+请求头+请求体）：**** 请求行： ①是请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。 ②为请求对应的URL地址，它和报文头的Host属性组成完整的请求URL。 ③是协议名称及版本号。 *请求头：* ④是HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。 与缓存相关的规则信息，均包含在header中** 请求体： ⑤是报文体，它将一个页面表单中的组件值通过param1=value1&amp;param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&amp;param2=value2”的方式传递请求参数。 *HTTP响应报文*HTTP的响应报文也由三部分组成（****响应行+响应头+响应体****） 响应行： ①报文协议及版本；②状态码及状态描述；**** 响应头： ③响应报文头，也是由多个属性组成； *响应体：* ④响应报文体，即我们真正要的“干货” this和e.targettarget触发事件的对象 this 绑定事件的对象 立即执行函数 最大的作用是：独立创建一个作用域，里面的变量不会有命名冲突的情况 1234567891011//(function()&#123;&#125;)()(function(a,b)&#123;console.log(a+b)&#125;)(1,2)//第二个小括号可以看做是调用函数//(function()&#123;&#125;());(function(a,b)&#123; console.log(a+b)&#125;(2,3)); v-bind和v-on缩写 vue修饰符.stop 调用event.stopPropagation() .prevent 调用event.preventDefault() .{keyCode|keyAlias}-只当事件是从特定键触发时才出发回调 .active 监听组件根元素的原生事件 .once 支出法一次回调 html的form表单表单是一个包含表单元素的区域。 表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。 表单使用表单标签 来设置: . *input 元素* . html标签 ，input表单12345678&lt;label for=&quot;&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;a&quot; id=&quot;&quot;&gt;&lt;/label&gt;&lt;label for=&quot;&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;a&quot; id=&quot;&quot;&gt;&lt;/label&gt;//name值相同，表单互斥 key标识符，key的值不同，key不进行复用12345678910&lt;div id=&quot;app&quot;&gt; &lt;span v-if=&quot;isuser&quot;&gt; 用户账号&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; key=&quot;key2&quot;&gt; &lt;/span&gt; &lt;span v-else&gt; 用户邮箱&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; key=&quot;key1&quot;&gt; &lt;/span&gt; &lt;button @click=&#x27;isuser=!isuser&#x27;&gt;切换类型&lt;/button&gt;&lt;/div&gt; v-if和v-show v-for：key主要作用是为了高效的更新虚拟DOM 123 &lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/div&gt; v-model实现表单元素和数据的双向绑定 v-model和checkbox的组合使用12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; value=&#x27;yu&#x27; v-model=&quot;something&quot;&gt;yu &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; value=&#x27;pi&#x27; v-model=&quot;something&quot;&gt;pi &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; value=&#x27;aa&#x27; v-model=&quot;something&quot;&gt;aa &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; value=&#x27;vv&#x27; v-model=&quot;something&quot;&gt;vv &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; value=&#x27;xx&#x27; v-model=&quot;something&quot;&gt;xx &lt;h2&gt;爱好：&#123;&#123;something&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; const app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; something:[] &#125; &#125;)&lt;/script&gt; v-model和下拉选择框select12345678910111213141516171819//multiple可以按住ctrl选择多个 &lt;div id=&quot;app&quot;&gt;&lt;select name=&quot;&quot; id=&quot;&quot; v-model=&quot;something&quot;multiple&gt; &lt;option value=&quot;a&quot; &gt;a&lt;/option&gt; &lt;option value=&quot;b&quot; &gt;b&lt;/option&gt; &lt;option value=&quot;c&quot; &gt;c&lt;/option&gt; &lt;option value=&quot;d&quot; &gt;d&lt;/option&gt; &lt;option value=&quot;e&quot; &gt;e&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;&#123;&#123;something&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; something:[] &#125; &#125;) &lt;/script&gt; v-bind修饰符（lazy，number，trim） 数组更新（是响应式的） push()添加数组后第一个元素 pop()删除数组后第一个元素 shift()删除数组最前元素 unshift()添加数组最前元素 splice() sort() reverse() Vue.set(修改的对象，索引值，修改后的值)computed 计算属性filter 过滤器reduce用法 1array.reduce(function(total, currentValue, currentIndex, arr), initialValue) vue组件化创建组件构造器 注册组件 使用组件 全局组件：123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;!-- 使用组件 --&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;script&gt; // 创建组件构造器对象 const cpn = Vue.extend(&#123; template: `&lt;div&gt; &lt;h1&gt;你好&lt;/h1&gt;&lt;/div&gt;` &#125;) // 注册组件（全局组件，意味着可以在多个vue实例下面使用） Vue.component(&#x27;my-cpn&#x27;, cpn) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125; &#125;)&lt;/script&gt; 局部组件：123456789101112131415161718192021 &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用组件 --&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;/div&gt;// 创建组件构造器对象 const cpn = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h1&gt;你好&lt;/h1&gt; &lt;/div&gt;` &#125;) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, components:&#123; &#x27;my-cpn&#x27;:cpn &#125; &#125;) 父子组件1234567891011121314151617181920212223242526272829303132333435 &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用组件 --&gt;&lt;cpn2&gt;&lt;/cpn2&gt; &lt;/div&gt; &lt;script&gt; // 创建第一个组件(子组件) const cpn1 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h1&gt;你好&lt;/h1&gt; &lt;/div&gt;` &#125;) // 创造第二个组件（父组件） const cpn2 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h1&gt;好啊&lt;/h1&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;/div&gt;` ,components:&#123; &#x27;cpn1&#x27;:cpn1 &#125; &#125;) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, components:&#123; &#x27;cpn2&#x27;: cpn2 &#125; &#125;) &lt;/script&gt; 全局组件的语法糖注册方式1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;!-- 使用组件 --&gt; &lt;cpn1&gt;&lt;/cpn1&gt;&lt;/div&gt;&lt;script&gt; // 创建并注册组件（全局组件） Vue.component(&#x27;cpn1&#x27;, &#123; template: `&lt;div&gt; &lt;h1&gt;你好&lt;/h1&gt;&lt;/div&gt;` &#125;) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125; &#125;)&lt;/script&gt; 注册局部组件的语法糖1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;!-- 使用组件 --&gt; &lt;cpn1&gt;&lt;/cpn1&gt;&lt;/div&gt;&lt;script&gt; // 创建并注册组件 const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, components: &#123; &#x27;cpn1&#x27;: &#123; template: `&lt;div&gt; &lt;h1&gt;你好&lt;/h1&gt;&lt;/div&gt;` &#125; &#125; &#125;)&lt;/script&gt; 模板的分离写法（局部组件） props （英文properties缩写）123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;cpn :cmovice=&#x27;movice&#x27; :cmessage=&#x27;message&#x27;&gt;&lt;/cpn&gt;//记得在组件标签绑定属性&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2 v-for=&quot;(item, index) in cmovice&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const cpn = &#123; template: &#x27;#cpn&#x27;, props: &#123; cmovice: Array, cmessage: String &#125; &#125; const ram = new Vue(&#123; el: &quot;#app&quot;, data: &#123; movice: [&#x27;adasd&#x27;, 214, 666], message: &#x27;dadasd&#x27; &#125;, components: &#123; &#x27;cpn&#x27;: cpn &#125; &#125;)&lt;/script&gt; 1234567891011121314151617//props的三种写法props:&#123;message:string&#125;props：[]props:&#123;message:&#123;type:string//提供默认值default:&#x27;&#x27;&#125;&#125; 组件标签驼峰写法不支持 myMessage转化为my-message父子组件的通信父传子：props 子传父：$emit //事件名称自建 $emit(事件名称，事件) 插槽 12345678910111213141516171819 &lt;cpn&gt;&lt;p slot=&#x27;left&#x27;&gt; sdad &lt;/p&gt;&lt;/cpn&gt;&lt;template id=&quot;app&quot;&gt; &lt;div&gt; &lt;h2&gt;计数器&#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;button @click=&#x27;ad&#x27;&gt;+&lt;/button&gt;&lt;button @click=&#x27;jian&#x27;&gt;-&lt;/button&gt; //插槽 &lt;slot name=&#x27;left&#x27;&gt;&lt;/slot&gt; &lt;slot name=&#x27;center&#x27;&gt;&lt;/slot&gt; &lt;slot name=right&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 作用域 模块化封装导入导出 CommonJS模块化 ES6模块化实现 export/import 1&lt;script src=&quot;xx.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; 1export&#123;name,flag&#125; 1import&#123;name,flag&#125;from&#x27;xxx.js&#x27; 导出函数或类 export default （只允许存在一个default） 统一全部导入//aaa是自定义的对象名 import *as aaa from ‘xxx.js’ //使用 console.log(aaa.flag) vue cli2","categories":[],"tags":[]},{"title":"","slug":"javascript","date":"2021-10-09T07:16:23.766Z","updated":"2021-07-26T03:15:23.582Z","comments":true,"path":"2021/10/09/javascript/","link":"","permalink":"http://example.com/2021/10/09/javascript/","excerpt":"","text":"this对象的理解正确的是 () 123在不改变this指向的前提下，this总是指向函数的直接调用者如果有new关键字，this指向new出来的那个对象IE中attachEvent中的this总是指向全局对象Window AMD和CMD都是浏览器端的js模块化规范，分别由require.js和sea.js实现。 CommonJS是服务器端的js模块化规范，由NodeJS实现。 JavaScript RegExp 对象有 3 个方法：test()、exec() 和 compile()。（1）test() 方法用来检测一个字符串是否匹配某个正则表达式，如果匹配成功，返回 true ，否则返回 false； （2）exec() 方法用来检索字符串中与正则表达式匹配的值。exec() 方法返回一个数组，其中存放匹配的结果。如果未找到匹配的值，则返回 null； （3）compile() 方法可以在脚本执行过程中编译正则表达式，也可以改变已有表达式。 string，Array，TypeArray,Map,Set内置可迭代对象 不支持冒泡：妈（mouseenter）妈(mouseleave)不(blur)放(focus)心你(load,unload,resize) 请给出[5&lt;6&lt;3,3&lt;2&lt;4]代码的运行结果 12345[true,true]js运算符是从左到右计算5&lt;6 为true true =1 ， 所以1&lt;3为true3&lt;2为false false=0， 所以0&lt;3为true 12345onmousedown：某个鼠标按键被按下onkeyup这个事件在用户放开任何先前按下的键盘键时发生。onkeypress:是用户按下数字，字母键的时候，触发！（可以不放开，按住不放的话，会连续触发）onblur 失去焦点onFocus 获得焦点 Math.round(）函数返回一个数字四舍五入后最接近的整数 如果参数的小数部分大于0.5，四舍五入到相邻的绝对值更大的整数 如果参数的小数部分小于0.5，四舍五入到相邻的绝对值更小的整数 如果参数的小数部分等于0.5，四舍五入到相邻的在正无穷（+∞）方向上的整数。 1.concat（）把元素衔接到数组中。 concat() 方法用于连接两个或多个数组。 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 2.every() 方法使用指定函数检测数组中的所有元素： 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。 如果所有元素都满足条件，则返回 true 3.filter（）返回满足断言函数的数组元素。 4.forEach（）为数组的每一个元素调用指定函数。 5indexOf（）在数组中查找指定元素。 如果找到的话返回该元素的索引 没找到 返回-1 6.join（）将数组的所有元素转化为字符串。 7.lastIndexOf（）在数组中反向查找。 8.map()从数组的元素中，计算出新的数组。 9.some（）测试是否至少有一个数组元素能让断言函数为真。 10.slice（）返回数组的一部分。 11.reduce（）从数组的元素中，计算出一个值。 参数接收一个函数 函数中接收两个参数 第一个是数组的值，第二个是初始值，不传的话就是0 循环调用该函数 前一个的返回值是后面的第二个参数 12.reduceRight（）从右往左计算数组 0 == false 1==true 常见HTTP状态码： 200 —— 请求成功 301 —— 资源（网页等）被永久转移到其他URL 404 —— 请求的资源（网页等）不存在 500 —— 内部服务器错误 400（错误请求） 服务器不理解请求的语法。 401（身份验证错误） 此页要求授权。您可能不希望将此网页纳入索引。 403（禁止） 服务器拒绝请求。 404（未找到） 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码 有时需要将网页中的一些数据保存在浏览器端，这样做的好处是，当下次访问页面时，不需要再次向服务器请求数据，直接就可以从本地读取数据。目前常用的有以下几种方法： cookie cookie会随着每次HTTP请求头信息一起发送，无形中增加了网络流量，另外，cookie能存储的数据容量有限，根据浏览器类型不同而不同，IE6大约只能存储2K。 Flash ShareObject 这种方式能能解决上面提到的cookie存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个Flash，当浏览器没有安装Flash控件时就不能用了。所幸的是，没有安装Flash的用户极少。 缺点：需要安装Flash插件。 Google Gear Google开发出的一种本地存储技术。 缺点：需要安装Gear组件。 userData IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。 sessionStorage 使用于Firefox2+的火狐浏览器，用这种方式存储的数据仅窗口级别有效，同一个窗口（或者Tab）页面刷新或者跳转，都能获取到本地存储的数据，当新开窗口或者页面时，原来的数据就失效了。 缺点：IE不支持、不能实现数据的持久保存。 globalStorage 使用于Firefox2+的火狐浏览器，类似于IE的userData。 History对象的属性或方法 length 返回浏览器历史列表中的URL数量 back() 加载 history 列表中的前一个URL forward() 加载 history 列表中的下一个URL go() 加载history列表中的某个具体页面。 [ ]转成0 true转成1 null == undefined parseFloat 解析一个字符串，并返回一个浮点数 toFixed 把数字转换为字符串，结果的小数点后有指定位数的数字 Math.round 把一个数字舍入为最接近的整数 toPrecision 把数字格式化为指定的长度 正则表达式 两种创建方法： 1.利用RegExp对象来创建 var regexp=new RegExp(/123/); 2.利用字面量创建 var rg=/123/ test方法来检测字符串是否符合正则表达式要求的规范 console.log(re.test(123)) 1234为class为test的div对象设置红色背景的正确js代码&lt;div class=&quot;test&quot;&gt;&lt;/div&gt; document.getElementsByClassName(&quot;test&quot;)[0].style.backgroundColor=&quot;red&quot;;在js里面添加的属性名使用驼峰法，在css里面使用连接线 除了id和query 其他返回的都是节点列表 以下是四种touch事件 touchstart: //手指放到屏幕上时触发 touchmove: //手指在屏幕上滑动式触发 touchend: //手指离开屏幕时触发 touchcancel: //系统取消touch事件的时候触发，这个好像比较少用 每个触摸事件被触发后，会生成一个event对象，event对象里额外包括以下三个触摸列表 touches: //当前屏幕上所有手指的列表 targetTouches: //当前dom元素上手指的列表，尽量使用这个代替touches changedTouches: //涉及当前事件的手指的列表，尽量使用这个代替touches 数据类型 转换为true的值 转换为false的值 Boolean true false String 任何非空字符串 “”空字符串 Number 任何非0数字值(包括无穷大) 0和NaN Object 任何对象 null Undefined n/a undefined 常见的事件： \\1. 点击事件： \\1. onclick：单击事件 \\2. ondblclick：双击事件 \\2. 焦点事件 \\1. onblur：失去焦点 \\2. onfocus:元素获得焦点。 \\3. 加载事件： \\1. onload：一张页面或一幅图像完成加载。 \\4. 鼠标事件： \\1. onmousedown 鼠标按钮被按下。 \\2. onmouseup 鼠标按键被松开。 \\3. onmousemove 鼠标被移动。 \\4. onmouseover 鼠标移到某元素之上。 \\5. onmouseout 鼠标从某元素移开。 \\5. 键盘事件： \\1. onkeydown 某个键盘按键被按下。 \\2. onkeyup 某个键盘按键被松开。 \\3. onkeypress 某个键盘按键被按下并松开。 \\6. 选择和改变 \\1. onchange 域的内容被改变。 \\2. onselect 文本被选中。 \\7. 表单事件： \\1. onsubmit 确认按钮被点击。 \\2. onreset 重置按钮被点击。 Angular大大减少了对DOM的访问。 jQuery极大的丰富了DOM操作 NOSCRIPT标签用来定义在脚本未被执行时的替代内容。也可以用在检测浏览器是否支持脚本，若不支持脚本则可以显示NOSCRIPT标签里的innerText noscript:用以在不支持js的浏览器中显示替代的内容，这个元素可以包含能够出现在文档中任何html元素，script元素除外。包含在noscript元素的内容只有在下列情况下才会显示出来1.浏览器不支持脚本2.浏览器支持脚本，但脚本被禁用 Ajax的优势 可搜索性普通的文本网页会更有利于SEO。文本内容是搜索引擎容易检索的，而繁琐的swf字节码却是搜索引擎不愿触及的。虽然Google等一些大型的搜索引擎可以检索SWF内部的内容，但是仍然有很多麻烦存在。 开放性Flash常年以来被Macromedia看的很死。包括Flex、FMS等辅佐技术一直都需要昂贵的安装、维护费用。而JS则没有这样的麻烦。没有人愿意承担法律和版权的风险。 费用Flash开发是很昂贵的，因为FlashIDE等环境都是要收费的．而Ajax则不同．虽然有一些便宜的生成swf的工具，但是他们的工能实在无法满足复杂需求。 易用性Ajax程序有更好的易用性。由于中间有一层Flashplayer***层，因此许多辅助功能无法被Flash灵活利用。而且Flash在一些方面有着不好的口碑。比如弹出广告、比如恶意代码。（awflasher.com个人认为这八成是乱上xx网站造成的） 易于开发人们开发复杂的Ajax和Flash应用程序时，都会借助一些高级的开发工具。普遍来说，Ajax的开发包比Flash简便、容易。 Flash的优势多媒体处理Flash在音频、视频等多媒体领域相比HTML有绝对的优势。现在几乎所有的网站都包含有Flash内容。 兼容性兼容性好：由于通过了唯一的FlashPlayer“***”。人们不必像调试JS那样，在不同的浏览器中调试程序。 矢量图型这是Flash最大的优势，同样处在这一领域的SVG、Canvas element以及Direct完全不能与Flash相比。 客户端资源调度Flash能够更容易的调用浏览器以外的外部资源。比如摄像头、麦克风等。然而这是普通的HTML无法完成的。但是这也许是一个缺点（为什么呢？） 代码回收规则如下： 1.全局变量不会被回收。 2.局部变量会被回收，也就是函数一旦运行完以后，函数内部的东西都会被销毁。 3.只要被另外一个作用域所引用就不会被回收 下面三个事件都是事件对象的方法： stopPropagation() 阻止事件冒泡。 这个事件不会阻止定义在元素上的其他事件。 stopImmediatePropagation() 会彻底的阻止事件， 在其之后的绑定在元素上的其他监听事件都不会触发 preventDefault() 阻止事件的默认动作 Promise 对象代表一个异步操作，有3种状态：Pending(进行中)、Resolved(已完成，又称Fulfilled)和Rejected(已完成)’。 ES5 orEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 ES6 中都会将空位当做undefined 任何对象转为布尔值，都为得到 true 在 JS 中，只有 0，-0，NaN，””，null，undefined 这六个值转布尔值时，结果为 false Angular 的知识，没有$send. $emit只能向parent controller传递event与data $broadcast只能向child controller传递event与data $on用于接收event与data 考察原型，js原型遵循5个规则： 1、所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了“null”以外）； 2、所有的引用类型（数组、对象、函数），都有一个__proto__（隐式原型）属性，属性值是一个普通的对象； 3、所有的函数，都有一个prototype（显式原型）属性，属性值也是一个普通对象； 4、所有的引用类型（数组、对象、函数），__proto__属性值指向（完全相等）它的构造函数的“prototype”属性 5、当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去proto（即它的构造函数的prototype中）寻找。 修改this指针的3个方法， call, apply, bind. 3者均可call、 bind、 apply 这三个函数的第一个参数都是this的指向对象，第二个参数差别就来了： call 的参数是直接放进去的，第二第三第n个参数全都用逗号分隔。 apply的所有参数都必须放在一个数组里面传进去。 bind除了返回函数以外，它的参数和call 一样 12345678function baz(a,b) &#123; console.log(this,a,b)&#125;baz.call(obj_a,2,3) //调用call()方法后this指向传入的第一个参数,后面的参数直接传入,第二个第三个之间用逗号分开baz.apply(obj_a,[1,2]) //apply方法和call的作用完全一样,但除第一个参数外其余参数要以数组的形式传入baz.bind(obj_a,1,2)() //返回的是一个函数,必须调用才能执行baz.bind(obj_a,[1,2])() 123456var x = 5; // 初始化 xelem = document.getElementById(&quot;demo&quot;); // 查找元素elem.innerHTML = x + &quot; &quot; + y; // 显示 x 和 yvar y = 7; // 初始化 y 实例 2 的 y 输出了 undefined，这是因为变量声明 (var y) 提升了，但是初始化(y = 7) 并不会提升，所以 y 变量是一个未定义的变量。 实例 2 类似以下代码: 1234567var x = 5; // 初始化 xvar y; // 声明 yelem = document.getElementById(&quot;demo&quot;); // 查找元素elem.innerHTML = x + &quot; &quot; + y; // 显示 x 和 yy = 7; // 设置 y 为 7 12345678Navagator：提供有关浏览器的信息Window：Window对象处于对象层次的最顶层，它提供了处理Navagator窗口的方法和属性Location：提供了与当前打开的URL一起工作的方法和属性，是一个静态的对象History：提供了与历史清单有关的信息Document：包含与文档元素一起工作的对象，它将这些元素封装起来供编程人员使用 css回流必将引起重绘，重绘不一定会引起回流 当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 会导致回流的操作： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的DOM元素 激活CSS伪类（例如：:hover） 查询某些属性或调用某些方法 一些常用且会导致回流的属性和方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 123456789101112131415161718192021如何避免回流，重绘CSS避免使用table布局。尽可能在DOM树的最末端改变class。避免设置多层内联样式。将动画效果应用到position属性为absolute或fixed的元素上。避免使用CSS表达式（例如：calc()）。JavaScript避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。作者：腰花链接：https://juejin.cn/post/6844903569087266823来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 相对定位(relative)，不脱离文档流，根据自身的位置进行偏移 绝对定位(absolute)，脱离文档流，如果父元素没有进行position，相对于浏览器左上角进行定位，否则相对于父元素定位 固定定位(fixed)，脱离文档流，相对于浏览器左上角定位 什么是SVG? SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用来定义用于网络的基于矢量的图形SVG 使用 XML 格式定义图形SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失SVG 是万维网联盟的标准 SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 (SVG是HTML下的一个分支) 总结一下伪类与伪元素的特性及其区别： 伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息； 伪元素本质上是创建了一个有内容的虚拟容器； CSS3中伪类和伪元素的语法不同； 伪类 :link :hover 伪元素 ::before ::after 可以同时使用多个伪类，而只能同时使用一个伪元素； 其中伪类和伪元素的根本区别在于：它们是否创造了新的元素,, 这个新创造的元素就叫 “伪无素” 。 伪元素/伪对象：不存在在DOM文档中，是虚拟的元素，是创建新元素。 这个新元素(伪元素) 是某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中. 伪类：存在DOM文档中，(无标签,找不到, 只有符合触发条件时才能看到 ), 逻辑上存在但在文档树中却无须标识的“幽灵”分类。 6. 因为伪类是类似于添加类所以可以是多个，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾 7. W3C中对于二者应用的描述(描述太模糊, 不容易理解)： 伪类：用于向某些选择器添加特殊的效果 伪元素：用于将特殊的效果添加到某些选择器(标签 主流浏览器内核私有属性css前缀： mozilla内核 (firefox,flock等) -moz webkit内核(safari,chrome等) -webkit opera内核(opera浏览器) -o trident内核(ie浏览器) -ms 12345关于link与@import的区别:区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。 ele.clientWidth = 宽度 + padding ele.offsetWidth = 宽度 + padding + border ele.scrollTop = 被卷去的上侧距离 ele.scrollHeight = 自身实际的高度（不包括边框） CSS 百分比参照问题 参照父元素宽度的元素：padding margin width text-indent 参照父元素高度的元素：height 参照父元素属性:font-size line-height 特殊：相对定位的时候，top(bottom) left(right)参照的是父元素的内容区域的高度与宽度，而绝对定位的时候参照的是最近的定位元素包含padding的高度与宽度 a:link,a:visited,a:hover,a:active 分别是什么意思? \\1. link:连接平常的状态 \\2. visited:连接被访问过之后 \\3. hover:鼠标放到连接上的时候 \\4. active:连接被按下的时候 正确顺序：“爱恨原则”（LoVe/HAte） 【 驴哈（LVHA）】，即四种伪类的首字母:LVHA。再重复一遍正确的顺序：a:link、a:visited、a:hover、a:active （1）highlight jQuery中的，突出特效，通过改变背景颜色来隐藏或者显示一个元素 （2）mark h5中的标签，定义带有记号的文本，文本高亮显示 （3）strong HTML中的标签，定义重要文本，用来加粗文本 （4）blink 是js中的方法，用于显示闪动的字符串，不能用于ie，Chrome，Safari 创建 块格式化上下文 *BFC* 的方式： 根元素() 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 paint 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 一、无继承性的属性 1、display：规定元素应该生成的框的类型 2、文本属性： vertical-align：垂直文本对齐 text-decoration：规定添加到文本的装饰 text-shadow：文本阴影效果 white-space：空白符的处理 unicode-bidi：设置文本的方向 3、盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left 4、背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment 5、定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index 6、生成内容属性：content、counter-reset、counter-increment 7、轮廓样式属性：outline-style、outline-width、outline-color、outline 8、页面样式属性：size、page-break-before、page-break-after 9、声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during CSS中Position属性有四个可选值，它们分别是：static、absolute、fixed、relative、sticky ◆position:static 无定位 ◆position:absolute 绝对定位 ◆position:fixed 相对于窗口的固定定位 ◆position:relative 相对定位 ◆position:sticky 粘性定位 visibility:hidden 隐藏元素，但仍占据布局中的空间。 display:none 从文档中删除元素。它不会占据任何空间。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-05-29T02:59:56.972Z","updated":"2021-05-29T02:59:56.972Z","comments":true,"path":"2021/05/29/hello-world/","link":"","permalink":"http://example.com/2021/05/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}